// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gopls

import (
	"context"
	"github.com/nicolas-martin/cube/internal/golang_org_x_tools/lsp/protocol"
	"sync"
)

var (
	lockServerMockCodeAction                sync.RWMutex
	lockServerMockCodeLens                  sync.RWMutex
	lockServerMockColorPresentation         sync.RWMutex
	lockServerMockCompletion                sync.RWMutex
	lockServerMockDeclaration               sync.RWMutex
	lockServerMockDefinition                sync.RWMutex
	lockServerMockDidChange                 sync.RWMutex
	lockServerMockDidChangeConfiguration    sync.RWMutex
	lockServerMockDidChangeWatchedFiles     sync.RWMutex
	lockServerMockDidChangeWorkspaceFolders sync.RWMutex
	lockServerMockDidClose                  sync.RWMutex
	lockServerMockDidOpen                   sync.RWMutex
	lockServerMockDidSave                   sync.RWMutex
	lockServerMockDocumentColor             sync.RWMutex
	lockServerMockDocumentHighlight         sync.RWMutex
	lockServerMockDocumentLink              sync.RWMutex
	lockServerMockDocumentSymbol            sync.RWMutex
	lockServerMockExecuteCommand            sync.RWMutex
	lockServerMockExit                      sync.RWMutex
	lockServerMockFoldingRange              sync.RWMutex
	lockServerMockFormatting                sync.RWMutex
	lockServerMockHover                     sync.RWMutex
	lockServerMockImplementation            sync.RWMutex
	lockServerMockIncomingCalls             sync.RWMutex
	lockServerMockInitialize                sync.RWMutex
	lockServerMockInitialized               sync.RWMutex
	lockServerMockLogTraceNotification      sync.RWMutex
	lockServerMockNonstandardRequest        sync.RWMutex
	lockServerMockOnTypeFormatting          sync.RWMutex
	lockServerMockOutgoingCalls             sync.RWMutex
	lockServerMockPrepareCallHierarchy      sync.RWMutex
	lockServerMockPrepareRename             sync.RWMutex
	lockServerMockProgress                  sync.RWMutex
	lockServerMockRangeFormatting           sync.RWMutex
	lockServerMockReferences                sync.RWMutex
	lockServerMockRename                    sync.RWMutex
	lockServerMockResolve                   sync.RWMutex
	lockServerMockResolveCodeLens           sync.RWMutex
	lockServerMockResolveDocumentLink       sync.RWMutex
	lockServerMockSelectionRange            sync.RWMutex
	lockServerMockSemanticTokens            sync.RWMutex
	lockServerMockSemanticTokensEdits       sync.RWMutex
	lockServerMockSemanticTokensRange       sync.RWMutex
	lockServerMockSetTraceNotification      sync.RWMutex
	lockServerMockShutdown                  sync.RWMutex
	lockServerMockSignatureHelp             sync.RWMutex
	lockServerMockSymbol                    sync.RWMutex
	lockServerMockTypeDefinition            sync.RWMutex
	lockServerMockWillSave                  sync.RWMutex
	lockServerMockWillSaveWaitUntil         sync.RWMutex
	lockServerMockWorkDoneProgressCancel    sync.RWMutex
	lockServerMockWorkDoneProgressCreate    sync.RWMutex
)

// Ensure, that ServerMock does implement protocol.Server.
// If this is not the case, regenerate this file with moq.
var _ protocol.Server = &ServerMock{}

// ServerMock is a mock implementation of protocol.Server.
//
//     func TestSomethingThatUsesServer(t *testing.T) {
//
//         // make and configure a mocked protocol.Server
//         mockedServer := &ServerMock{
//             CodeActionFunc: func(in1 context.Context, in2 *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
// 	               panic("mock out the CodeAction method")
//             },
//             CodeLensFunc: func(in1 context.Context, in2 *protocol.CodeLensParams) ([]protocol.CodeLens, error) {
// 	               panic("mock out the CodeLens method")
//             },
//             ColorPresentationFunc: func(in1 context.Context, in2 *protocol.ColorPresentationParams) ([]protocol.ColorPresentation, error) {
// 	               panic("mock out the ColorPresentation method")
//             },
//             CompletionFunc: func(in1 context.Context, in2 *protocol.CompletionParams) (*protocol.CompletionList, error) {
// 	               panic("mock out the Completion method")
//             },
//             DeclarationFunc: func(in1 context.Context, in2 *protocol.DeclarationParams) ([]protocol.Location, error) {
// 	               panic("mock out the Declaration method")
//             },
//             DefinitionFunc: func(in1 context.Context, in2 *protocol.DefinitionParams) ([]protocol.Location, error) {
// 	               panic("mock out the Definition method")
//             },
//             DidChangeFunc: func(in1 context.Context, in2 *protocol.DidChangeTextDocumentParams) error {
// 	               panic("mock out the DidChange method")
//             },
//             DidChangeConfigurationFunc: func(in1 context.Context, in2 *protocol.DidChangeConfigurationParams) error {
// 	               panic("mock out the DidChangeConfiguration method")
//             },
//             DidChangeWatchedFilesFunc: func(in1 context.Context, in2 *protocol.DidChangeWatchedFilesParams) error {
// 	               panic("mock out the DidChangeWatchedFiles method")
//             },
//             DidChangeWorkspaceFoldersFunc: func(in1 context.Context, in2 *protocol.DidChangeWorkspaceFoldersParams) error {
// 	               panic("mock out the DidChangeWorkspaceFolders method")
//             },
//             DidCloseFunc: func(in1 context.Context, in2 *protocol.DidCloseTextDocumentParams) error {
// 	               panic("mock out the DidClose method")
//             },
//             DidOpenFunc: func(in1 context.Context, in2 *protocol.DidOpenTextDocumentParams) error {
// 	               panic("mock out the DidOpen method")
//             },
//             DidSaveFunc: func(in1 context.Context, in2 *protocol.DidSaveTextDocumentParams) error {
// 	               panic("mock out the DidSave method")
//             },
//             DocumentColorFunc: func(in1 context.Context, in2 *protocol.DocumentColorParams) ([]protocol.ColorInformation, error) {
// 	               panic("mock out the DocumentColor method")
//             },
//             DocumentHighlightFunc: func(in1 context.Context, in2 *protocol.DocumentHighlightParams) ([]protocol.DocumentHighlight, error) {
// 	               panic("mock out the DocumentHighlight method")
//             },
//             DocumentLinkFunc: func(in1 context.Context, in2 *protocol.DocumentLinkParams) ([]protocol.DocumentLink, error) {
// 	               panic("mock out the DocumentLink method")
//             },
//             DocumentSymbolFunc: func(in1 context.Context, in2 *protocol.DocumentSymbolParams) ([]protocol.DocumentSymbol, error) {
// 	               panic("mock out the DocumentSymbol method")
//             },
//             ExecuteCommandFunc: func(in1 context.Context, in2 *protocol.ExecuteCommandParams) (interface{}, error) {
// 	               panic("mock out the ExecuteCommand method")
//             },
//             ExitFunc: func(in1 context.Context) error {
// 	               panic("mock out the Exit method")
//             },
//             FoldingRangeFunc: func(in1 context.Context, in2 *protocol.FoldingRangeParams) ([]protocol.FoldingRange, error) {
// 	               panic("mock out the FoldingRange method")
//             },
//             FormattingFunc: func(in1 context.Context, in2 *protocol.DocumentFormattingParams) ([]protocol.TextEdit, error) {
// 	               panic("mock out the Formatting method")
//             },
//             HoverFunc: func(in1 context.Context, in2 *protocol.HoverParams) (*protocol.Hover, error) {
// 	               panic("mock out the Hover method")
//             },
//             ImplementationFunc: func(in1 context.Context, in2 *protocol.ImplementationParams) ([]protocol.Location, error) {
// 	               panic("mock out the Implementation method")
//             },
//             IncomingCallsFunc: func(in1 context.Context, in2 *protocol.CallHierarchyIncomingCallsParams) ([]protocol.CallHierarchyIncomingCall, error) {
// 	               panic("mock out the IncomingCalls method")
//             },
//             InitializeFunc: func(in1 context.Context, in2 *protocol.ParamInitialize) (*protocol.InitializeResult, error) {
// 	               panic("mock out the Initialize method")
//             },
//             InitializedFunc: func(in1 context.Context, in2 *protocol.InitializedParams) error {
// 	               panic("mock out the Initialized method")
//             },
//             LogTraceNotificationFunc: func(in1 context.Context, in2 *protocol.LogTraceParams) error {
// 	               panic("mock out the LogTraceNotification method")
//             },
//             NonstandardRequestFunc: func(ctx context.Context, method string, params interface{}) (interface{}, error) {
// 	               panic("mock out the NonstandardRequest method")
//             },
//             OnTypeFormattingFunc: func(in1 context.Context, in2 *protocol.DocumentOnTypeFormattingParams) ([]protocol.TextEdit, error) {
// 	               panic("mock out the OnTypeFormatting method")
//             },
//             OutgoingCallsFunc: func(in1 context.Context, in2 *protocol.CallHierarchyOutgoingCallsParams) ([]protocol.CallHierarchyOutgoingCall, error) {
// 	               panic("mock out the OutgoingCalls method")
//             },
//             PrepareCallHierarchyFunc: func(in1 context.Context, in2 *protocol.CallHierarchyPrepareParams) ([]protocol.CallHierarchyItem, error) {
// 	               panic("mock out the PrepareCallHierarchy method")
//             },
//             PrepareRenameFunc: func(in1 context.Context, in2 *protocol.PrepareRenameParams) (interface{}, error) {
// 	               panic("mock out the PrepareRename method")
//             },
//             ProgressFunc: func(in1 context.Context, in2 *protocol.ProgressParams) error {
// 	               panic("mock out the Progress method")
//             },
//             RangeFormattingFunc: func(in1 context.Context, in2 *protocol.DocumentRangeFormattingParams) ([]protocol.TextEdit, error) {
// 	               panic("mock out the RangeFormatting method")
//             },
//             ReferencesFunc: func(in1 context.Context, in2 *protocol.ReferenceParams) ([]protocol.Location, error) {
// 	               panic("mock out the References method")
//             },
//             RenameFunc: func(in1 context.Context, in2 *protocol.RenameParams) (*protocol.WorkspaceEdit, error) {
// 	               panic("mock out the Rename method")
//             },
//             ResolveFunc: func(in1 context.Context, in2 *protocol.CompletionItem) (*protocol.CompletionItem, error) {
// 	               panic("mock out the Resolve method")
//             },
//             ResolveCodeLensFunc: func(in1 context.Context, in2 *protocol.CodeLens) (*protocol.CodeLens, error) {
// 	               panic("mock out the ResolveCodeLens method")
//             },
//             ResolveDocumentLinkFunc: func(in1 context.Context, in2 *protocol.DocumentLink) (*protocol.DocumentLink, error) {
// 	               panic("mock out the ResolveDocumentLink method")
//             },
//             SelectionRangeFunc: func(in1 context.Context, in2 *protocol.SelectionRangeParams) ([]protocol.SelectionRange, error) {
// 	               panic("mock out the SelectionRange method")
//             },
//             SemanticTokensFunc: func(in1 context.Context, in2 *protocol.SemanticTokensParams) (*protocol.SemanticTokens, error) {
// 	               panic("mock out the SemanticTokens method")
//             },
//             SemanticTokensEditsFunc: func(in1 context.Context, in2 *protocol.SemanticTokensEditsParams) (interface{}, error) {
// 	               panic("mock out the SemanticTokensEdits method")
//             },
//             SemanticTokensRangeFunc: func(in1 context.Context, in2 *protocol.SemanticTokensRangeParams) (*protocol.SemanticTokens, error) {
// 	               panic("mock out the SemanticTokensRange method")
//             },
//             SetTraceNotificationFunc: func(in1 context.Context, in2 *protocol.SetTraceParams) error {
// 	               panic("mock out the SetTraceNotification method")
//             },
//             ShutdownFunc: func(in1 context.Context) error {
// 	               panic("mock out the Shutdown method")
//             },
//             SignatureHelpFunc: func(in1 context.Context, in2 *protocol.SignatureHelpParams) (*protocol.SignatureHelp, error) {
// 	               panic("mock out the SignatureHelp method")
//             },
//             SymbolFunc: func(in1 context.Context, in2 *protocol.WorkspaceSymbolParams) ([]protocol.SymbolInformation, error) {
// 	               panic("mock out the Symbol method")
//             },
//             TypeDefinitionFunc: func(in1 context.Context, in2 *protocol.TypeDefinitionParams) ([]protocol.Location, error) {
// 	               panic("mock out the TypeDefinition method")
//             },
//             WillSaveFunc: func(in1 context.Context, in2 *protocol.WillSaveTextDocumentParams) error {
// 	               panic("mock out the WillSave method")
//             },
//             WillSaveWaitUntilFunc: func(in1 context.Context, in2 *protocol.WillSaveTextDocumentParams) ([]protocol.TextEdit, error) {
// 	               panic("mock out the WillSaveWaitUntil method")
//             },
//             WorkDoneProgressCancelFunc: func(in1 context.Context, in2 *protocol.WorkDoneProgressCancelParams) error {
// 	               panic("mock out the WorkDoneProgressCancel method")
//             },
//             WorkDoneProgressCreateFunc: func(in1 context.Context, in2 *protocol.WorkDoneProgressCreateParams) error {
// 	               panic("mock out the WorkDoneProgressCreate method")
//             },
//         }
//
//         // use mockedServer in code that requires protocol.Server
//         // and then make assertions.
//
//     }
type ServerMock struct {
	// CodeActionFunc mocks the CodeAction method.
	CodeActionFunc func(in1 context.Context, in2 *protocol.CodeActionParams) ([]protocol.CodeAction, error)

	// CodeLensFunc mocks the CodeLens method.
	CodeLensFunc func(in1 context.Context, in2 *protocol.CodeLensParams) ([]protocol.CodeLens, error)

	// ColorPresentationFunc mocks the ColorPresentation method.
	ColorPresentationFunc func(in1 context.Context, in2 *protocol.ColorPresentationParams) ([]protocol.ColorPresentation, error)

	// CompletionFunc mocks the Completion method.
	CompletionFunc func(in1 context.Context, in2 *protocol.CompletionParams) (*protocol.CompletionList, error)

	// DeclarationFunc mocks the Declaration method.
	DeclarationFunc func(in1 context.Context, in2 *protocol.DeclarationParams) ([]protocol.Location, error)

	// DefinitionFunc mocks the Definition method.
	DefinitionFunc func(in1 context.Context, in2 *protocol.DefinitionParams) ([]protocol.Location, error)

	// DidChangeFunc mocks the DidChange method.
	DidChangeFunc func(in1 context.Context, in2 *protocol.DidChangeTextDocumentParams) error

	// DidChangeConfigurationFunc mocks the DidChangeConfiguration method.
	DidChangeConfigurationFunc func(in1 context.Context, in2 *protocol.DidChangeConfigurationParams) error

	// DidChangeWatchedFilesFunc mocks the DidChangeWatchedFiles method.
	DidChangeWatchedFilesFunc func(in1 context.Context, in2 *protocol.DidChangeWatchedFilesParams) error

	// DidChangeWorkspaceFoldersFunc mocks the DidChangeWorkspaceFolders method.
	DidChangeWorkspaceFoldersFunc func(in1 context.Context, in2 *protocol.DidChangeWorkspaceFoldersParams) error

	// DidCloseFunc mocks the DidClose method.
	DidCloseFunc func(in1 context.Context, in2 *protocol.DidCloseTextDocumentParams) error

	// DidOpenFunc mocks the DidOpen method.
	DidOpenFunc func(in1 context.Context, in2 *protocol.DidOpenTextDocumentParams) error

	// DidSaveFunc mocks the DidSave method.
	DidSaveFunc func(in1 context.Context, in2 *protocol.DidSaveTextDocumentParams) error

	// DocumentColorFunc mocks the DocumentColor method.
	DocumentColorFunc func(in1 context.Context, in2 *protocol.DocumentColorParams) ([]protocol.ColorInformation, error)

	// DocumentHighlightFunc mocks the DocumentHighlight method.
	DocumentHighlightFunc func(in1 context.Context, in2 *protocol.DocumentHighlightParams) ([]protocol.DocumentHighlight, error)

	// DocumentLinkFunc mocks the DocumentLink method.
	DocumentLinkFunc func(in1 context.Context, in2 *protocol.DocumentLinkParams) ([]protocol.DocumentLink, error)

	// DocumentSymbolFunc mocks the DocumentSymbol method.
	DocumentSymbolFunc func(in1 context.Context, in2 *protocol.DocumentSymbolParams) ([]protocol.DocumentSymbol, error)

	// ExecuteCommandFunc mocks the ExecuteCommand method.
	ExecuteCommandFunc func(in1 context.Context, in2 *protocol.ExecuteCommandParams) (interface{}, error)

	// ExitFunc mocks the Exit method.
	ExitFunc func(in1 context.Context) error

	// FoldingRangeFunc mocks the FoldingRange method.
	FoldingRangeFunc func(in1 context.Context, in2 *protocol.FoldingRangeParams) ([]protocol.FoldingRange, error)

	// FormattingFunc mocks the Formatting method.
	FormattingFunc func(in1 context.Context, in2 *protocol.DocumentFormattingParams) ([]protocol.TextEdit, error)

	// HoverFunc mocks the Hover method.
	HoverFunc func(in1 context.Context, in2 *protocol.HoverParams) (*protocol.Hover, error)

	// ImplementationFunc mocks the Implementation method.
	ImplementationFunc func(in1 context.Context, in2 *protocol.ImplementationParams) ([]protocol.Location, error)

	// IncomingCallsFunc mocks the IncomingCalls method.
	IncomingCallsFunc func(in1 context.Context, in2 *protocol.CallHierarchyIncomingCallsParams) ([]protocol.CallHierarchyIncomingCall, error)

	// InitializeFunc mocks the Initialize method.
	InitializeFunc func(in1 context.Context, in2 *protocol.ParamInitialize) (*protocol.InitializeResult, error)

	// InitializedFunc mocks the Initialized method.
	InitializedFunc func(in1 context.Context, in2 *protocol.InitializedParams) error

	// LogTraceNotificationFunc mocks the LogTraceNotification method.
	LogTraceNotificationFunc func(in1 context.Context, in2 *protocol.LogTraceParams) error

	// NonstandardRequestFunc mocks the NonstandardRequest method.
	NonstandardRequestFunc func(ctx context.Context, method string, params interface{}) (interface{}, error)

	// OnTypeFormattingFunc mocks the OnTypeFormatting method.
	OnTypeFormattingFunc func(in1 context.Context, in2 *protocol.DocumentOnTypeFormattingParams) ([]protocol.TextEdit, error)

	// OutgoingCallsFunc mocks the OutgoingCalls method.
	OutgoingCallsFunc func(in1 context.Context, in2 *protocol.CallHierarchyOutgoingCallsParams) ([]protocol.CallHierarchyOutgoingCall, error)

	// PrepareCallHierarchyFunc mocks the PrepareCallHierarchy method.
	PrepareCallHierarchyFunc func(in1 context.Context, in2 *protocol.CallHierarchyPrepareParams) ([]protocol.CallHierarchyItem, error)

	// PrepareRenameFunc mocks the PrepareRename method.
	PrepareRenameFunc func(in1 context.Context, in2 *protocol.PrepareRenameParams) (interface{}, error)

	// ProgressFunc mocks the Progress method.
	ProgressFunc func(in1 context.Context, in2 *protocol.ProgressParams) error

	// RangeFormattingFunc mocks the RangeFormatting method.
	RangeFormattingFunc func(in1 context.Context, in2 *protocol.DocumentRangeFormattingParams) ([]protocol.TextEdit, error)

	// ReferencesFunc mocks the References method.
	ReferencesFunc func(in1 context.Context, in2 *protocol.ReferenceParams) ([]protocol.Location, error)

	// RenameFunc mocks the Rename method.
	RenameFunc func(in1 context.Context, in2 *protocol.RenameParams) (*protocol.WorkspaceEdit, error)

	// ResolveFunc mocks the Resolve method.
	ResolveFunc func(in1 context.Context, in2 *protocol.CompletionItem) (*protocol.CompletionItem, error)

	// ResolveCodeLensFunc mocks the ResolveCodeLens method.
	ResolveCodeLensFunc func(in1 context.Context, in2 *protocol.CodeLens) (*protocol.CodeLens, error)

	// ResolveDocumentLinkFunc mocks the ResolveDocumentLink method.
	ResolveDocumentLinkFunc func(in1 context.Context, in2 *protocol.DocumentLink) (*protocol.DocumentLink, error)

	// SelectionRangeFunc mocks the SelectionRange method.
	SelectionRangeFunc func(in1 context.Context, in2 *protocol.SelectionRangeParams) ([]protocol.SelectionRange, error)

	// SemanticTokensFunc mocks the SemanticTokens method.
	SemanticTokensFunc func(in1 context.Context, in2 *protocol.SemanticTokensParams) (*protocol.SemanticTokens, error)

	// SemanticTokensEditsFunc mocks the SemanticTokensEdits method.
	SemanticTokensEditsFunc func(in1 context.Context, in2 *protocol.SemanticTokensEditsParams) (interface{}, error)

	// SemanticTokensRangeFunc mocks the SemanticTokensRange method.
	SemanticTokensRangeFunc func(in1 context.Context, in2 *protocol.SemanticTokensRangeParams) (*protocol.SemanticTokens, error)

	// SetTraceNotificationFunc mocks the SetTraceNotification method.
	SetTraceNotificationFunc func(in1 context.Context, in2 *protocol.SetTraceParams) error

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func(in1 context.Context) error

	// SignatureHelpFunc mocks the SignatureHelp method.
	SignatureHelpFunc func(in1 context.Context, in2 *protocol.SignatureHelpParams) (*protocol.SignatureHelp, error)

	// SymbolFunc mocks the Symbol method.
	SymbolFunc func(in1 context.Context, in2 *protocol.WorkspaceSymbolParams) ([]protocol.SymbolInformation, error)

	// TypeDefinitionFunc mocks the TypeDefinition method.
	TypeDefinitionFunc func(in1 context.Context, in2 *protocol.TypeDefinitionParams) ([]protocol.Location, error)

	// WillSaveFunc mocks the WillSave method.
	WillSaveFunc func(in1 context.Context, in2 *protocol.WillSaveTextDocumentParams) error

	// WillSaveWaitUntilFunc mocks the WillSaveWaitUntil method.
	WillSaveWaitUntilFunc func(in1 context.Context, in2 *protocol.WillSaveTextDocumentParams) ([]protocol.TextEdit, error)

	// WorkDoneProgressCancelFunc mocks the WorkDoneProgressCancel method.
	WorkDoneProgressCancelFunc func(in1 context.Context, in2 *protocol.WorkDoneProgressCancelParams) error

	// WorkDoneProgressCreateFunc mocks the WorkDoneProgressCreate method.
	WorkDoneProgressCreateFunc func(in1 context.Context, in2 *protocol.WorkDoneProgressCreateParams) error

	// calls tracks calls to the methods.
	calls struct {
		// CodeAction holds details about calls to the CodeAction method.
		CodeAction []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.CodeActionParams
		}
		// CodeLens holds details about calls to the CodeLens method.
		CodeLens []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.CodeLensParams
		}
		// ColorPresentation holds details about calls to the ColorPresentation method.
		ColorPresentation []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.ColorPresentationParams
		}
		// Completion holds details about calls to the Completion method.
		Completion []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.CompletionParams
		}
		// Declaration holds details about calls to the Declaration method.
		Declaration []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DeclarationParams
		}
		// Definition holds details about calls to the Definition method.
		Definition []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DefinitionParams
		}
		// DidChange holds details about calls to the DidChange method.
		DidChange []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DidChangeTextDocumentParams
		}
		// DidChangeConfiguration holds details about calls to the DidChangeConfiguration method.
		DidChangeConfiguration []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DidChangeConfigurationParams
		}
		// DidChangeWatchedFiles holds details about calls to the DidChangeWatchedFiles method.
		DidChangeWatchedFiles []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DidChangeWatchedFilesParams
		}
		// DidChangeWorkspaceFolders holds details about calls to the DidChangeWorkspaceFolders method.
		DidChangeWorkspaceFolders []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DidChangeWorkspaceFoldersParams
		}
		// DidClose holds details about calls to the DidClose method.
		DidClose []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DidCloseTextDocumentParams
		}
		// DidOpen holds details about calls to the DidOpen method.
		DidOpen []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DidOpenTextDocumentParams
		}
		// DidSave holds details about calls to the DidSave method.
		DidSave []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DidSaveTextDocumentParams
		}
		// DocumentColor holds details about calls to the DocumentColor method.
		DocumentColor []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DocumentColorParams
		}
		// DocumentHighlight holds details about calls to the DocumentHighlight method.
		DocumentHighlight []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DocumentHighlightParams
		}
		// DocumentLink holds details about calls to the DocumentLink method.
		DocumentLink []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DocumentLinkParams
		}
		// DocumentSymbol holds details about calls to the DocumentSymbol method.
		DocumentSymbol []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DocumentSymbolParams
		}
		// ExecuteCommand holds details about calls to the ExecuteCommand method.
		ExecuteCommand []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.ExecuteCommandParams
		}
		// Exit holds details about calls to the Exit method.
		Exit []struct {
			// In1 is the in1 argument value.
			In1 context.Context
		}
		// FoldingRange holds details about calls to the FoldingRange method.
		FoldingRange []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.FoldingRangeParams
		}
		// Formatting holds details about calls to the Formatting method.
		Formatting []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DocumentFormattingParams
		}
		// Hover holds details about calls to the Hover method.
		Hover []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.HoverParams
		}
		// Implementation holds details about calls to the Implementation method.
		Implementation []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.ImplementationParams
		}
		// IncomingCalls holds details about calls to the IncomingCalls method.
		IncomingCalls []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.CallHierarchyIncomingCallsParams
		}
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.ParamInitialize
		}
		// Initialized holds details about calls to the Initialized method.
		Initialized []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.InitializedParams
		}
		// LogTraceNotification holds details about calls to the LogTraceNotification method.
		LogTraceNotification []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.LogTraceParams
		}
		// NonstandardRequest holds details about calls to the NonstandardRequest method.
		NonstandardRequest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Method is the method argument value.
			Method string
			// Params is the params argument value.
			Params interface{}
		}
		// OnTypeFormatting holds details about calls to the OnTypeFormatting method.
		OnTypeFormatting []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DocumentOnTypeFormattingParams
		}
		// OutgoingCalls holds details about calls to the OutgoingCalls method.
		OutgoingCalls []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.CallHierarchyOutgoingCallsParams
		}
		// PrepareCallHierarchy holds details about calls to the PrepareCallHierarchy method.
		PrepareCallHierarchy []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.CallHierarchyPrepareParams
		}
		// PrepareRename holds details about calls to the PrepareRename method.
		PrepareRename []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.PrepareRenameParams
		}
		// Progress holds details about calls to the Progress method.
		Progress []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.ProgressParams
		}
		// RangeFormatting holds details about calls to the RangeFormatting method.
		RangeFormatting []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DocumentRangeFormattingParams
		}
		// References holds details about calls to the References method.
		References []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.ReferenceParams
		}
		// Rename holds details about calls to the Rename method.
		Rename []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.RenameParams
		}
		// Resolve holds details about calls to the Resolve method.
		Resolve []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.CompletionItem
		}
		// ResolveCodeLens holds details about calls to the ResolveCodeLens method.
		ResolveCodeLens []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.CodeLens
		}
		// ResolveDocumentLink holds details about calls to the ResolveDocumentLink method.
		ResolveDocumentLink []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.DocumentLink
		}
		// SelectionRange holds details about calls to the SelectionRange method.
		SelectionRange []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.SelectionRangeParams
		}
		// SemanticTokens holds details about calls to the SemanticTokens method.
		SemanticTokens []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.SemanticTokensParams
		}
		// SemanticTokensEdits holds details about calls to the SemanticTokensEdits method.
		SemanticTokensEdits []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.SemanticTokensEditsParams
		}
		// SemanticTokensRange holds details about calls to the SemanticTokensRange method.
		SemanticTokensRange []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.SemanticTokensRangeParams
		}
		// SetTraceNotification holds details about calls to the SetTraceNotification method.
		SetTraceNotification []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.SetTraceParams
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
			// In1 is the in1 argument value.
			In1 context.Context
		}
		// SignatureHelp holds details about calls to the SignatureHelp method.
		SignatureHelp []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.SignatureHelpParams
		}
		// Symbol holds details about calls to the Symbol method.
		Symbol []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.WorkspaceSymbolParams
		}
		// TypeDefinition holds details about calls to the TypeDefinition method.
		TypeDefinition []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.TypeDefinitionParams
		}
		// WillSave holds details about calls to the WillSave method.
		WillSave []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.WillSaveTextDocumentParams
		}
		// WillSaveWaitUntil holds details about calls to the WillSaveWaitUntil method.
		WillSaveWaitUntil []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.WillSaveTextDocumentParams
		}
		// WorkDoneProgressCancel holds details about calls to the WorkDoneProgressCancel method.
		WorkDoneProgressCancel []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.WorkDoneProgressCancelParams
		}
		// WorkDoneProgressCreate holds details about calls to the WorkDoneProgressCreate method.
		WorkDoneProgressCreate []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *protocol.WorkDoneProgressCreateParams
		}
	}
}

// CodeAction calls CodeActionFunc.
func (mock *ServerMock) CodeAction(in1 context.Context, in2 *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	if mock.CodeActionFunc == nil {
		panic("ServerMock.CodeActionFunc: method is nil but Server.CodeAction was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.CodeActionParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockCodeAction.Lock()
	mock.calls.CodeAction = append(mock.calls.CodeAction, callInfo)
	lockServerMockCodeAction.Unlock()
	return mock.CodeActionFunc(in1, in2)
}

// CodeActionCalls gets all the calls that were made to CodeAction.
// Check the length with:
//     len(mockedServer.CodeActionCalls())
func (mock *ServerMock) CodeActionCalls() []struct {
	In1 context.Context
	In2 *protocol.CodeActionParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.CodeActionParams
	}
	lockServerMockCodeAction.RLock()
	calls = mock.calls.CodeAction
	lockServerMockCodeAction.RUnlock()
	return calls
}

// CodeLens calls CodeLensFunc.
func (mock *ServerMock) CodeLens(in1 context.Context, in2 *protocol.CodeLensParams) ([]protocol.CodeLens, error) {
	if mock.CodeLensFunc == nil {
		panic("ServerMock.CodeLensFunc: method is nil but Server.CodeLens was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.CodeLensParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockCodeLens.Lock()
	mock.calls.CodeLens = append(mock.calls.CodeLens, callInfo)
	lockServerMockCodeLens.Unlock()
	return mock.CodeLensFunc(in1, in2)
}

// CodeLensCalls gets all the calls that were made to CodeLens.
// Check the length with:
//     len(mockedServer.CodeLensCalls())
func (mock *ServerMock) CodeLensCalls() []struct {
	In1 context.Context
	In2 *protocol.CodeLensParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.CodeLensParams
	}
	lockServerMockCodeLens.RLock()
	calls = mock.calls.CodeLens
	lockServerMockCodeLens.RUnlock()
	return calls
}

// ColorPresentation calls ColorPresentationFunc.
func (mock *ServerMock) ColorPresentation(in1 context.Context, in2 *protocol.ColorPresentationParams) ([]protocol.ColorPresentation, error) {
	if mock.ColorPresentationFunc == nil {
		panic("ServerMock.ColorPresentationFunc: method is nil but Server.ColorPresentation was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.ColorPresentationParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockColorPresentation.Lock()
	mock.calls.ColorPresentation = append(mock.calls.ColorPresentation, callInfo)
	lockServerMockColorPresentation.Unlock()
	return mock.ColorPresentationFunc(in1, in2)
}

// ColorPresentationCalls gets all the calls that were made to ColorPresentation.
// Check the length with:
//     len(mockedServer.ColorPresentationCalls())
func (mock *ServerMock) ColorPresentationCalls() []struct {
	In1 context.Context
	In2 *protocol.ColorPresentationParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.ColorPresentationParams
	}
	lockServerMockColorPresentation.RLock()
	calls = mock.calls.ColorPresentation
	lockServerMockColorPresentation.RUnlock()
	return calls
}

// Completion calls CompletionFunc.
func (mock *ServerMock) Completion(in1 context.Context, in2 *protocol.CompletionParams) (*protocol.CompletionList, error) {
	if mock.CompletionFunc == nil {
		panic("ServerMock.CompletionFunc: method is nil but Server.Completion was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.CompletionParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockCompletion.Lock()
	mock.calls.Completion = append(mock.calls.Completion, callInfo)
	lockServerMockCompletion.Unlock()
	return mock.CompletionFunc(in1, in2)
}

// CompletionCalls gets all the calls that were made to Completion.
// Check the length with:
//     len(mockedServer.CompletionCalls())
func (mock *ServerMock) CompletionCalls() []struct {
	In1 context.Context
	In2 *protocol.CompletionParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.CompletionParams
	}
	lockServerMockCompletion.RLock()
	calls = mock.calls.Completion
	lockServerMockCompletion.RUnlock()
	return calls
}

// Declaration calls DeclarationFunc.
func (mock *ServerMock) Declaration(in1 context.Context, in2 *protocol.DeclarationParams) ([]protocol.Location, error) {
	if mock.DeclarationFunc == nil {
		panic("ServerMock.DeclarationFunc: method is nil but Server.Declaration was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DeclarationParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDeclaration.Lock()
	mock.calls.Declaration = append(mock.calls.Declaration, callInfo)
	lockServerMockDeclaration.Unlock()
	return mock.DeclarationFunc(in1, in2)
}

// DeclarationCalls gets all the calls that were made to Declaration.
// Check the length with:
//     len(mockedServer.DeclarationCalls())
func (mock *ServerMock) DeclarationCalls() []struct {
	In1 context.Context
	In2 *protocol.DeclarationParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DeclarationParams
	}
	lockServerMockDeclaration.RLock()
	calls = mock.calls.Declaration
	lockServerMockDeclaration.RUnlock()
	return calls
}

// Definition calls DefinitionFunc.
func (mock *ServerMock) Definition(in1 context.Context, in2 *protocol.DefinitionParams) ([]protocol.Location, error) {
	if mock.DefinitionFunc == nil {
		panic("ServerMock.DefinitionFunc: method is nil but Server.Definition was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DefinitionParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDefinition.Lock()
	mock.calls.Definition = append(mock.calls.Definition, callInfo)
	lockServerMockDefinition.Unlock()
	return mock.DefinitionFunc(in1, in2)
}

// DefinitionCalls gets all the calls that were made to Definition.
// Check the length with:
//     len(mockedServer.DefinitionCalls())
func (mock *ServerMock) DefinitionCalls() []struct {
	In1 context.Context
	In2 *protocol.DefinitionParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DefinitionParams
	}
	lockServerMockDefinition.RLock()
	calls = mock.calls.Definition
	lockServerMockDefinition.RUnlock()
	return calls
}

// DidChange calls DidChangeFunc.
func (mock *ServerMock) DidChange(in1 context.Context, in2 *protocol.DidChangeTextDocumentParams) error {
	if mock.DidChangeFunc == nil {
		panic("ServerMock.DidChangeFunc: method is nil but Server.DidChange was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DidChangeTextDocumentParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDidChange.Lock()
	mock.calls.DidChange = append(mock.calls.DidChange, callInfo)
	lockServerMockDidChange.Unlock()
	return mock.DidChangeFunc(in1, in2)
}

// DidChangeCalls gets all the calls that were made to DidChange.
// Check the length with:
//     len(mockedServer.DidChangeCalls())
func (mock *ServerMock) DidChangeCalls() []struct {
	In1 context.Context
	In2 *protocol.DidChangeTextDocumentParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DidChangeTextDocumentParams
	}
	lockServerMockDidChange.RLock()
	calls = mock.calls.DidChange
	lockServerMockDidChange.RUnlock()
	return calls
}

// DidChangeConfiguration calls DidChangeConfigurationFunc.
func (mock *ServerMock) DidChangeConfiguration(in1 context.Context, in2 *protocol.DidChangeConfigurationParams) error {
	if mock.DidChangeConfigurationFunc == nil {
		panic("ServerMock.DidChangeConfigurationFunc: method is nil but Server.DidChangeConfiguration was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DidChangeConfigurationParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDidChangeConfiguration.Lock()
	mock.calls.DidChangeConfiguration = append(mock.calls.DidChangeConfiguration, callInfo)
	lockServerMockDidChangeConfiguration.Unlock()
	return mock.DidChangeConfigurationFunc(in1, in2)
}

// DidChangeConfigurationCalls gets all the calls that were made to DidChangeConfiguration.
// Check the length with:
//     len(mockedServer.DidChangeConfigurationCalls())
func (mock *ServerMock) DidChangeConfigurationCalls() []struct {
	In1 context.Context
	In2 *protocol.DidChangeConfigurationParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DidChangeConfigurationParams
	}
	lockServerMockDidChangeConfiguration.RLock()
	calls = mock.calls.DidChangeConfiguration
	lockServerMockDidChangeConfiguration.RUnlock()
	return calls
}

// DidChangeWatchedFiles calls DidChangeWatchedFilesFunc.
func (mock *ServerMock) DidChangeWatchedFiles(in1 context.Context, in2 *protocol.DidChangeWatchedFilesParams) error {
	if mock.DidChangeWatchedFilesFunc == nil {
		panic("ServerMock.DidChangeWatchedFilesFunc: method is nil but Server.DidChangeWatchedFiles was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DidChangeWatchedFilesParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDidChangeWatchedFiles.Lock()
	mock.calls.DidChangeWatchedFiles = append(mock.calls.DidChangeWatchedFiles, callInfo)
	lockServerMockDidChangeWatchedFiles.Unlock()
	return mock.DidChangeWatchedFilesFunc(in1, in2)
}

// DidChangeWatchedFilesCalls gets all the calls that were made to DidChangeWatchedFiles.
// Check the length with:
//     len(mockedServer.DidChangeWatchedFilesCalls())
func (mock *ServerMock) DidChangeWatchedFilesCalls() []struct {
	In1 context.Context
	In2 *protocol.DidChangeWatchedFilesParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DidChangeWatchedFilesParams
	}
	lockServerMockDidChangeWatchedFiles.RLock()
	calls = mock.calls.DidChangeWatchedFiles
	lockServerMockDidChangeWatchedFiles.RUnlock()
	return calls
}

// DidChangeWorkspaceFolders calls DidChangeWorkspaceFoldersFunc.
func (mock *ServerMock) DidChangeWorkspaceFolders(in1 context.Context, in2 *protocol.DidChangeWorkspaceFoldersParams) error {
	if mock.DidChangeWorkspaceFoldersFunc == nil {
		panic("ServerMock.DidChangeWorkspaceFoldersFunc: method is nil but Server.DidChangeWorkspaceFolders was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DidChangeWorkspaceFoldersParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDidChangeWorkspaceFolders.Lock()
	mock.calls.DidChangeWorkspaceFolders = append(mock.calls.DidChangeWorkspaceFolders, callInfo)
	lockServerMockDidChangeWorkspaceFolders.Unlock()
	return mock.DidChangeWorkspaceFoldersFunc(in1, in2)
}

// DidChangeWorkspaceFoldersCalls gets all the calls that were made to DidChangeWorkspaceFolders.
// Check the length with:
//     len(mockedServer.DidChangeWorkspaceFoldersCalls())
func (mock *ServerMock) DidChangeWorkspaceFoldersCalls() []struct {
	In1 context.Context
	In2 *protocol.DidChangeWorkspaceFoldersParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DidChangeWorkspaceFoldersParams
	}
	lockServerMockDidChangeWorkspaceFolders.RLock()
	calls = mock.calls.DidChangeWorkspaceFolders
	lockServerMockDidChangeWorkspaceFolders.RUnlock()
	return calls
}

// DidClose calls DidCloseFunc.
func (mock *ServerMock) DidClose(in1 context.Context, in2 *protocol.DidCloseTextDocumentParams) error {
	if mock.DidCloseFunc == nil {
		panic("ServerMock.DidCloseFunc: method is nil but Server.DidClose was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DidCloseTextDocumentParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDidClose.Lock()
	mock.calls.DidClose = append(mock.calls.DidClose, callInfo)
	lockServerMockDidClose.Unlock()
	return mock.DidCloseFunc(in1, in2)
}

// DidCloseCalls gets all the calls that were made to DidClose.
// Check the length with:
//     len(mockedServer.DidCloseCalls())
func (mock *ServerMock) DidCloseCalls() []struct {
	In1 context.Context
	In2 *protocol.DidCloseTextDocumentParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DidCloseTextDocumentParams
	}
	lockServerMockDidClose.RLock()
	calls = mock.calls.DidClose
	lockServerMockDidClose.RUnlock()
	return calls
}

// DidOpen calls DidOpenFunc.
func (mock *ServerMock) DidOpen(in1 context.Context, in2 *protocol.DidOpenTextDocumentParams) error {
	if mock.DidOpenFunc == nil {
		panic("ServerMock.DidOpenFunc: method is nil but Server.DidOpen was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DidOpenTextDocumentParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDidOpen.Lock()
	mock.calls.DidOpen = append(mock.calls.DidOpen, callInfo)
	lockServerMockDidOpen.Unlock()
	return mock.DidOpenFunc(in1, in2)
}

// DidOpenCalls gets all the calls that were made to DidOpen.
// Check the length with:
//     len(mockedServer.DidOpenCalls())
func (mock *ServerMock) DidOpenCalls() []struct {
	In1 context.Context
	In2 *protocol.DidOpenTextDocumentParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DidOpenTextDocumentParams
	}
	lockServerMockDidOpen.RLock()
	calls = mock.calls.DidOpen
	lockServerMockDidOpen.RUnlock()
	return calls
}

// DidSave calls DidSaveFunc.
func (mock *ServerMock) DidSave(in1 context.Context, in2 *protocol.DidSaveTextDocumentParams) error {
	if mock.DidSaveFunc == nil {
		panic("ServerMock.DidSaveFunc: method is nil but Server.DidSave was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DidSaveTextDocumentParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDidSave.Lock()
	mock.calls.DidSave = append(mock.calls.DidSave, callInfo)
	lockServerMockDidSave.Unlock()
	return mock.DidSaveFunc(in1, in2)
}

// DidSaveCalls gets all the calls that were made to DidSave.
// Check the length with:
//     len(mockedServer.DidSaveCalls())
func (mock *ServerMock) DidSaveCalls() []struct {
	In1 context.Context
	In2 *protocol.DidSaveTextDocumentParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DidSaveTextDocumentParams
	}
	lockServerMockDidSave.RLock()
	calls = mock.calls.DidSave
	lockServerMockDidSave.RUnlock()
	return calls
}

// DocumentColor calls DocumentColorFunc.
func (mock *ServerMock) DocumentColor(in1 context.Context, in2 *protocol.DocumentColorParams) ([]protocol.ColorInformation, error) {
	if mock.DocumentColorFunc == nil {
		panic("ServerMock.DocumentColorFunc: method is nil but Server.DocumentColor was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DocumentColorParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDocumentColor.Lock()
	mock.calls.DocumentColor = append(mock.calls.DocumentColor, callInfo)
	lockServerMockDocumentColor.Unlock()
	return mock.DocumentColorFunc(in1, in2)
}

// DocumentColorCalls gets all the calls that were made to DocumentColor.
// Check the length with:
//     len(mockedServer.DocumentColorCalls())
func (mock *ServerMock) DocumentColorCalls() []struct {
	In1 context.Context
	In2 *protocol.DocumentColorParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DocumentColorParams
	}
	lockServerMockDocumentColor.RLock()
	calls = mock.calls.DocumentColor
	lockServerMockDocumentColor.RUnlock()
	return calls
}

// DocumentHighlight calls DocumentHighlightFunc.
func (mock *ServerMock) DocumentHighlight(in1 context.Context, in2 *protocol.DocumentHighlightParams) ([]protocol.DocumentHighlight, error) {
	if mock.DocumentHighlightFunc == nil {
		panic("ServerMock.DocumentHighlightFunc: method is nil but Server.DocumentHighlight was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DocumentHighlightParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDocumentHighlight.Lock()
	mock.calls.DocumentHighlight = append(mock.calls.DocumentHighlight, callInfo)
	lockServerMockDocumentHighlight.Unlock()
	return mock.DocumentHighlightFunc(in1, in2)
}

// DocumentHighlightCalls gets all the calls that were made to DocumentHighlight.
// Check the length with:
//     len(mockedServer.DocumentHighlightCalls())
func (mock *ServerMock) DocumentHighlightCalls() []struct {
	In1 context.Context
	In2 *protocol.DocumentHighlightParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DocumentHighlightParams
	}
	lockServerMockDocumentHighlight.RLock()
	calls = mock.calls.DocumentHighlight
	lockServerMockDocumentHighlight.RUnlock()
	return calls
}

// DocumentLink calls DocumentLinkFunc.
func (mock *ServerMock) DocumentLink(in1 context.Context, in2 *protocol.DocumentLinkParams) ([]protocol.DocumentLink, error) {
	if mock.DocumentLinkFunc == nil {
		panic("ServerMock.DocumentLinkFunc: method is nil but Server.DocumentLink was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DocumentLinkParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDocumentLink.Lock()
	mock.calls.DocumentLink = append(mock.calls.DocumentLink, callInfo)
	lockServerMockDocumentLink.Unlock()
	return mock.DocumentLinkFunc(in1, in2)
}

// DocumentLinkCalls gets all the calls that were made to DocumentLink.
// Check the length with:
//     len(mockedServer.DocumentLinkCalls())
func (mock *ServerMock) DocumentLinkCalls() []struct {
	In1 context.Context
	In2 *protocol.DocumentLinkParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DocumentLinkParams
	}
	lockServerMockDocumentLink.RLock()
	calls = mock.calls.DocumentLink
	lockServerMockDocumentLink.RUnlock()
	return calls
}

// DocumentSymbol calls DocumentSymbolFunc.
func (mock *ServerMock) DocumentSymbol(in1 context.Context, in2 *protocol.DocumentSymbolParams) ([]protocol.DocumentSymbol, error) {
	if mock.DocumentSymbolFunc == nil {
		panic("ServerMock.DocumentSymbolFunc: method is nil but Server.DocumentSymbol was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DocumentSymbolParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockDocumentSymbol.Lock()
	mock.calls.DocumentSymbol = append(mock.calls.DocumentSymbol, callInfo)
	lockServerMockDocumentSymbol.Unlock()
	return mock.DocumentSymbolFunc(in1, in2)
}

// DocumentSymbolCalls gets all the calls that were made to DocumentSymbol.
// Check the length with:
//     len(mockedServer.DocumentSymbolCalls())
func (mock *ServerMock) DocumentSymbolCalls() []struct {
	In1 context.Context
	In2 *protocol.DocumentSymbolParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DocumentSymbolParams
	}
	lockServerMockDocumentSymbol.RLock()
	calls = mock.calls.DocumentSymbol
	lockServerMockDocumentSymbol.RUnlock()
	return calls
}

// ExecuteCommand calls ExecuteCommandFunc.
func (mock *ServerMock) ExecuteCommand(in1 context.Context, in2 *protocol.ExecuteCommandParams) (interface{}, error) {
	if mock.ExecuteCommandFunc == nil {
		panic("ServerMock.ExecuteCommandFunc: method is nil but Server.ExecuteCommand was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.ExecuteCommandParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockExecuteCommand.Lock()
	mock.calls.ExecuteCommand = append(mock.calls.ExecuteCommand, callInfo)
	lockServerMockExecuteCommand.Unlock()
	return mock.ExecuteCommandFunc(in1, in2)
}

// ExecuteCommandCalls gets all the calls that were made to ExecuteCommand.
// Check the length with:
//     len(mockedServer.ExecuteCommandCalls())
func (mock *ServerMock) ExecuteCommandCalls() []struct {
	In1 context.Context
	In2 *protocol.ExecuteCommandParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.ExecuteCommandParams
	}
	lockServerMockExecuteCommand.RLock()
	calls = mock.calls.ExecuteCommand
	lockServerMockExecuteCommand.RUnlock()
	return calls
}

// Exit calls ExitFunc.
func (mock *ServerMock) Exit(in1 context.Context) error {
	if mock.ExitFunc == nil {
		panic("ServerMock.ExitFunc: method is nil but Server.Exit was just called")
	}
	callInfo := struct {
		In1 context.Context
	}{
		In1: in1,
	}
	lockServerMockExit.Lock()
	mock.calls.Exit = append(mock.calls.Exit, callInfo)
	lockServerMockExit.Unlock()
	return mock.ExitFunc(in1)
}

// ExitCalls gets all the calls that were made to Exit.
// Check the length with:
//     len(mockedServer.ExitCalls())
func (mock *ServerMock) ExitCalls() []struct {
	In1 context.Context
} {
	var calls []struct {
		In1 context.Context
	}
	lockServerMockExit.RLock()
	calls = mock.calls.Exit
	lockServerMockExit.RUnlock()
	return calls
}

// FoldingRange calls FoldingRangeFunc.
func (mock *ServerMock) FoldingRange(in1 context.Context, in2 *protocol.FoldingRangeParams) ([]protocol.FoldingRange, error) {
	if mock.FoldingRangeFunc == nil {
		panic("ServerMock.FoldingRangeFunc: method is nil but Server.FoldingRange was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.FoldingRangeParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockFoldingRange.Lock()
	mock.calls.FoldingRange = append(mock.calls.FoldingRange, callInfo)
	lockServerMockFoldingRange.Unlock()
	return mock.FoldingRangeFunc(in1, in2)
}

// FoldingRangeCalls gets all the calls that were made to FoldingRange.
// Check the length with:
//     len(mockedServer.FoldingRangeCalls())
func (mock *ServerMock) FoldingRangeCalls() []struct {
	In1 context.Context
	In2 *protocol.FoldingRangeParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.FoldingRangeParams
	}
	lockServerMockFoldingRange.RLock()
	calls = mock.calls.FoldingRange
	lockServerMockFoldingRange.RUnlock()
	return calls
}

// Formatting calls FormattingFunc.
func (mock *ServerMock) Formatting(in1 context.Context, in2 *protocol.DocumentFormattingParams) ([]protocol.TextEdit, error) {
	if mock.FormattingFunc == nil {
		panic("ServerMock.FormattingFunc: method is nil but Server.Formatting was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DocumentFormattingParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockFormatting.Lock()
	mock.calls.Formatting = append(mock.calls.Formatting, callInfo)
	lockServerMockFormatting.Unlock()
	return mock.FormattingFunc(in1, in2)
}

// FormattingCalls gets all the calls that were made to Formatting.
// Check the length with:
//     len(mockedServer.FormattingCalls())
func (mock *ServerMock) FormattingCalls() []struct {
	In1 context.Context
	In2 *protocol.DocumentFormattingParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DocumentFormattingParams
	}
	lockServerMockFormatting.RLock()
	calls = mock.calls.Formatting
	lockServerMockFormatting.RUnlock()
	return calls
}

// Hover calls HoverFunc.
func (mock *ServerMock) Hover(in1 context.Context, in2 *protocol.HoverParams) (*protocol.Hover, error) {
	if mock.HoverFunc == nil {
		panic("ServerMock.HoverFunc: method is nil but Server.Hover was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.HoverParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockHover.Lock()
	mock.calls.Hover = append(mock.calls.Hover, callInfo)
	lockServerMockHover.Unlock()
	return mock.HoverFunc(in1, in2)
}

// HoverCalls gets all the calls that were made to Hover.
// Check the length with:
//     len(mockedServer.HoverCalls())
func (mock *ServerMock) HoverCalls() []struct {
	In1 context.Context
	In2 *protocol.HoverParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.HoverParams
	}
	lockServerMockHover.RLock()
	calls = mock.calls.Hover
	lockServerMockHover.RUnlock()
	return calls
}

// Implementation calls ImplementationFunc.
func (mock *ServerMock) Implementation(in1 context.Context, in2 *protocol.ImplementationParams) ([]protocol.Location, error) {
	if mock.ImplementationFunc == nil {
		panic("ServerMock.ImplementationFunc: method is nil but Server.Implementation was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.ImplementationParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockImplementation.Lock()
	mock.calls.Implementation = append(mock.calls.Implementation, callInfo)
	lockServerMockImplementation.Unlock()
	return mock.ImplementationFunc(in1, in2)
}

// ImplementationCalls gets all the calls that were made to Implementation.
// Check the length with:
//     len(mockedServer.ImplementationCalls())
func (mock *ServerMock) ImplementationCalls() []struct {
	In1 context.Context
	In2 *protocol.ImplementationParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.ImplementationParams
	}
	lockServerMockImplementation.RLock()
	calls = mock.calls.Implementation
	lockServerMockImplementation.RUnlock()
	return calls
}

// IncomingCalls calls IncomingCallsFunc.
func (mock *ServerMock) IncomingCalls(in1 context.Context, in2 *protocol.CallHierarchyIncomingCallsParams) ([]protocol.CallHierarchyIncomingCall, error) {
	if mock.IncomingCallsFunc == nil {
		panic("ServerMock.IncomingCallsFunc: method is nil but Server.IncomingCalls was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.CallHierarchyIncomingCallsParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockIncomingCalls.Lock()
	mock.calls.IncomingCalls = append(mock.calls.IncomingCalls, callInfo)
	lockServerMockIncomingCalls.Unlock()
	return mock.IncomingCallsFunc(in1, in2)
}

// IncomingCallsCalls gets all the calls that were made to IncomingCalls.
// Check the length with:
//     len(mockedServer.IncomingCallsCalls())
func (mock *ServerMock) IncomingCallsCalls() []struct {
	In1 context.Context
	In2 *protocol.CallHierarchyIncomingCallsParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.CallHierarchyIncomingCallsParams
	}
	lockServerMockIncomingCalls.RLock()
	calls = mock.calls.IncomingCalls
	lockServerMockIncomingCalls.RUnlock()
	return calls
}

// Initialize calls InitializeFunc.
func (mock *ServerMock) Initialize(in1 context.Context, in2 *protocol.ParamInitialize) (*protocol.InitializeResult, error) {
	if mock.InitializeFunc == nil {
		panic("ServerMock.InitializeFunc: method is nil but Server.Initialize was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.ParamInitialize
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	lockServerMockInitialize.Unlock()
	return mock.InitializeFunc(in1, in2)
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//     len(mockedServer.InitializeCalls())
func (mock *ServerMock) InitializeCalls() []struct {
	In1 context.Context
	In2 *protocol.ParamInitialize
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.ParamInitialize
	}
	lockServerMockInitialize.RLock()
	calls = mock.calls.Initialize
	lockServerMockInitialize.RUnlock()
	return calls
}

// Initialized calls InitializedFunc.
func (mock *ServerMock) Initialized(in1 context.Context, in2 *protocol.InitializedParams) error {
	if mock.InitializedFunc == nil {
		panic("ServerMock.InitializedFunc: method is nil but Server.Initialized was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.InitializedParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockInitialized.Lock()
	mock.calls.Initialized = append(mock.calls.Initialized, callInfo)
	lockServerMockInitialized.Unlock()
	return mock.InitializedFunc(in1, in2)
}

// InitializedCalls gets all the calls that were made to Initialized.
// Check the length with:
//     len(mockedServer.InitializedCalls())
func (mock *ServerMock) InitializedCalls() []struct {
	In1 context.Context
	In2 *protocol.InitializedParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.InitializedParams
	}
	lockServerMockInitialized.RLock()
	calls = mock.calls.Initialized
	lockServerMockInitialized.RUnlock()
	return calls
}

// LogTraceNotification calls LogTraceNotificationFunc.
func (mock *ServerMock) LogTraceNotification(in1 context.Context, in2 *protocol.LogTraceParams) error {
	if mock.LogTraceNotificationFunc == nil {
		panic("ServerMock.LogTraceNotificationFunc: method is nil but Server.LogTraceNotification was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.LogTraceParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockLogTraceNotification.Lock()
	mock.calls.LogTraceNotification = append(mock.calls.LogTraceNotification, callInfo)
	lockServerMockLogTraceNotification.Unlock()
	return mock.LogTraceNotificationFunc(in1, in2)
}

// LogTraceNotificationCalls gets all the calls that were made to LogTraceNotification.
// Check the length with:
//     len(mockedServer.LogTraceNotificationCalls())
func (mock *ServerMock) LogTraceNotificationCalls() []struct {
	In1 context.Context
	In2 *protocol.LogTraceParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.LogTraceParams
	}
	lockServerMockLogTraceNotification.RLock()
	calls = mock.calls.LogTraceNotification
	lockServerMockLogTraceNotification.RUnlock()
	return calls
}

// NonstandardRequest calls NonstandardRequestFunc.
func (mock *ServerMock) NonstandardRequest(ctx context.Context, method string, params interface{}) (interface{}, error) {
	if mock.NonstandardRequestFunc == nil {
		panic("ServerMock.NonstandardRequestFunc: method is nil but Server.NonstandardRequest was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Method string
		Params interface{}
	}{
		Ctx:    ctx,
		Method: method,
		Params: params,
	}
	lockServerMockNonstandardRequest.Lock()
	mock.calls.NonstandardRequest = append(mock.calls.NonstandardRequest, callInfo)
	lockServerMockNonstandardRequest.Unlock()
	return mock.NonstandardRequestFunc(ctx, method, params)
}

// NonstandardRequestCalls gets all the calls that were made to NonstandardRequest.
// Check the length with:
//     len(mockedServer.NonstandardRequestCalls())
func (mock *ServerMock) NonstandardRequestCalls() []struct {
	Ctx    context.Context
	Method string
	Params interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Method string
		Params interface{}
	}
	lockServerMockNonstandardRequest.RLock()
	calls = mock.calls.NonstandardRequest
	lockServerMockNonstandardRequest.RUnlock()
	return calls
}

// OnTypeFormatting calls OnTypeFormattingFunc.
func (mock *ServerMock) OnTypeFormatting(in1 context.Context, in2 *protocol.DocumentOnTypeFormattingParams) ([]protocol.TextEdit, error) {
	if mock.OnTypeFormattingFunc == nil {
		panic("ServerMock.OnTypeFormattingFunc: method is nil but Server.OnTypeFormatting was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DocumentOnTypeFormattingParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockOnTypeFormatting.Lock()
	mock.calls.OnTypeFormatting = append(mock.calls.OnTypeFormatting, callInfo)
	lockServerMockOnTypeFormatting.Unlock()
	return mock.OnTypeFormattingFunc(in1, in2)
}

// OnTypeFormattingCalls gets all the calls that were made to OnTypeFormatting.
// Check the length with:
//     len(mockedServer.OnTypeFormattingCalls())
func (mock *ServerMock) OnTypeFormattingCalls() []struct {
	In1 context.Context
	In2 *protocol.DocumentOnTypeFormattingParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DocumentOnTypeFormattingParams
	}
	lockServerMockOnTypeFormatting.RLock()
	calls = mock.calls.OnTypeFormatting
	lockServerMockOnTypeFormatting.RUnlock()
	return calls
}

// OutgoingCalls calls OutgoingCallsFunc.
func (mock *ServerMock) OutgoingCalls(in1 context.Context, in2 *protocol.CallHierarchyOutgoingCallsParams) ([]protocol.CallHierarchyOutgoingCall, error) {
	if mock.OutgoingCallsFunc == nil {
		panic("ServerMock.OutgoingCallsFunc: method is nil but Server.OutgoingCalls was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.CallHierarchyOutgoingCallsParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockOutgoingCalls.Lock()
	mock.calls.OutgoingCalls = append(mock.calls.OutgoingCalls, callInfo)
	lockServerMockOutgoingCalls.Unlock()
	return mock.OutgoingCallsFunc(in1, in2)
}

// OutgoingCallsCalls gets all the calls that were made to OutgoingCalls.
// Check the length with:
//     len(mockedServer.OutgoingCallsCalls())
func (mock *ServerMock) OutgoingCallsCalls() []struct {
	In1 context.Context
	In2 *protocol.CallHierarchyOutgoingCallsParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.CallHierarchyOutgoingCallsParams
	}
	lockServerMockOutgoingCalls.RLock()
	calls = mock.calls.OutgoingCalls
	lockServerMockOutgoingCalls.RUnlock()
	return calls
}

// PrepareCallHierarchy calls PrepareCallHierarchyFunc.
func (mock *ServerMock) PrepareCallHierarchy(in1 context.Context, in2 *protocol.CallHierarchyPrepareParams) ([]protocol.CallHierarchyItem, error) {
	if mock.PrepareCallHierarchyFunc == nil {
		panic("ServerMock.PrepareCallHierarchyFunc: method is nil but Server.PrepareCallHierarchy was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.CallHierarchyPrepareParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockPrepareCallHierarchy.Lock()
	mock.calls.PrepareCallHierarchy = append(mock.calls.PrepareCallHierarchy, callInfo)
	lockServerMockPrepareCallHierarchy.Unlock()
	return mock.PrepareCallHierarchyFunc(in1, in2)
}

// PrepareCallHierarchyCalls gets all the calls that were made to PrepareCallHierarchy.
// Check the length with:
//     len(mockedServer.PrepareCallHierarchyCalls())
func (mock *ServerMock) PrepareCallHierarchyCalls() []struct {
	In1 context.Context
	In2 *protocol.CallHierarchyPrepareParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.CallHierarchyPrepareParams
	}
	lockServerMockPrepareCallHierarchy.RLock()
	calls = mock.calls.PrepareCallHierarchy
	lockServerMockPrepareCallHierarchy.RUnlock()
	return calls
}

// PrepareRename calls PrepareRenameFunc.
func (mock *ServerMock) PrepareRename(in1 context.Context, in2 *protocol.PrepareRenameParams) (interface{}, error) {
	if mock.PrepareRenameFunc == nil {
		panic("ServerMock.PrepareRenameFunc: method is nil but Server.PrepareRename was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.PrepareRenameParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockPrepareRename.Lock()
	mock.calls.PrepareRename = append(mock.calls.PrepareRename, callInfo)
	lockServerMockPrepareRename.Unlock()
	return mock.PrepareRenameFunc(in1, in2)
}

// PrepareRenameCalls gets all the calls that were made to PrepareRename.
// Check the length with:
//     len(mockedServer.PrepareRenameCalls())
func (mock *ServerMock) PrepareRenameCalls() []struct {
	In1 context.Context
	In2 *protocol.PrepareRenameParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.PrepareRenameParams
	}
	lockServerMockPrepareRename.RLock()
	calls = mock.calls.PrepareRename
	lockServerMockPrepareRename.RUnlock()
	return calls
}

// Progress calls ProgressFunc.
func (mock *ServerMock) Progress(in1 context.Context, in2 *protocol.ProgressParams) error {
	if mock.ProgressFunc == nil {
		panic("ServerMock.ProgressFunc: method is nil but Server.Progress was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.ProgressParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockProgress.Lock()
	mock.calls.Progress = append(mock.calls.Progress, callInfo)
	lockServerMockProgress.Unlock()
	return mock.ProgressFunc(in1, in2)
}

// ProgressCalls gets all the calls that were made to Progress.
// Check the length with:
//     len(mockedServer.ProgressCalls())
func (mock *ServerMock) ProgressCalls() []struct {
	In1 context.Context
	In2 *protocol.ProgressParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.ProgressParams
	}
	lockServerMockProgress.RLock()
	calls = mock.calls.Progress
	lockServerMockProgress.RUnlock()
	return calls
}

// RangeFormatting calls RangeFormattingFunc.
func (mock *ServerMock) RangeFormatting(in1 context.Context, in2 *protocol.DocumentRangeFormattingParams) ([]protocol.TextEdit, error) {
	if mock.RangeFormattingFunc == nil {
		panic("ServerMock.RangeFormattingFunc: method is nil but Server.RangeFormatting was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DocumentRangeFormattingParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockRangeFormatting.Lock()
	mock.calls.RangeFormatting = append(mock.calls.RangeFormatting, callInfo)
	lockServerMockRangeFormatting.Unlock()
	return mock.RangeFormattingFunc(in1, in2)
}

// RangeFormattingCalls gets all the calls that were made to RangeFormatting.
// Check the length with:
//     len(mockedServer.RangeFormattingCalls())
func (mock *ServerMock) RangeFormattingCalls() []struct {
	In1 context.Context
	In2 *protocol.DocumentRangeFormattingParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DocumentRangeFormattingParams
	}
	lockServerMockRangeFormatting.RLock()
	calls = mock.calls.RangeFormatting
	lockServerMockRangeFormatting.RUnlock()
	return calls
}

// References calls ReferencesFunc.
func (mock *ServerMock) References(in1 context.Context, in2 *protocol.ReferenceParams) ([]protocol.Location, error) {
	if mock.ReferencesFunc == nil {
		panic("ServerMock.ReferencesFunc: method is nil but Server.References was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.ReferenceParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockReferences.Lock()
	mock.calls.References = append(mock.calls.References, callInfo)
	lockServerMockReferences.Unlock()
	return mock.ReferencesFunc(in1, in2)
}

// ReferencesCalls gets all the calls that were made to References.
// Check the length with:
//     len(mockedServer.ReferencesCalls())
func (mock *ServerMock) ReferencesCalls() []struct {
	In1 context.Context
	In2 *protocol.ReferenceParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.ReferenceParams
	}
	lockServerMockReferences.RLock()
	calls = mock.calls.References
	lockServerMockReferences.RUnlock()
	return calls
}

// Rename calls RenameFunc.
func (mock *ServerMock) Rename(in1 context.Context, in2 *protocol.RenameParams) (*protocol.WorkspaceEdit, error) {
	if mock.RenameFunc == nil {
		panic("ServerMock.RenameFunc: method is nil but Server.Rename was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.RenameParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockRename.Lock()
	mock.calls.Rename = append(mock.calls.Rename, callInfo)
	lockServerMockRename.Unlock()
	return mock.RenameFunc(in1, in2)
}

// RenameCalls gets all the calls that were made to Rename.
// Check the length with:
//     len(mockedServer.RenameCalls())
func (mock *ServerMock) RenameCalls() []struct {
	In1 context.Context
	In2 *protocol.RenameParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.RenameParams
	}
	lockServerMockRename.RLock()
	calls = mock.calls.Rename
	lockServerMockRename.RUnlock()
	return calls
}

// Resolve calls ResolveFunc.
func (mock *ServerMock) Resolve(in1 context.Context, in2 *protocol.CompletionItem) (*protocol.CompletionItem, error) {
	if mock.ResolveFunc == nil {
		panic("ServerMock.ResolveFunc: method is nil but Server.Resolve was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.CompletionItem
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockResolve.Lock()
	mock.calls.Resolve = append(mock.calls.Resolve, callInfo)
	lockServerMockResolve.Unlock()
	return mock.ResolveFunc(in1, in2)
}

// ResolveCalls gets all the calls that were made to Resolve.
// Check the length with:
//     len(mockedServer.ResolveCalls())
func (mock *ServerMock) ResolveCalls() []struct {
	In1 context.Context
	In2 *protocol.CompletionItem
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.CompletionItem
	}
	lockServerMockResolve.RLock()
	calls = mock.calls.Resolve
	lockServerMockResolve.RUnlock()
	return calls
}

// ResolveCodeLens calls ResolveCodeLensFunc.
func (mock *ServerMock) ResolveCodeLens(in1 context.Context, in2 *protocol.CodeLens) (*protocol.CodeLens, error) {
	if mock.ResolveCodeLensFunc == nil {
		panic("ServerMock.ResolveCodeLensFunc: method is nil but Server.ResolveCodeLens was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.CodeLens
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockResolveCodeLens.Lock()
	mock.calls.ResolveCodeLens = append(mock.calls.ResolveCodeLens, callInfo)
	lockServerMockResolveCodeLens.Unlock()
	return mock.ResolveCodeLensFunc(in1, in2)
}

// ResolveCodeLensCalls gets all the calls that were made to ResolveCodeLens.
// Check the length with:
//     len(mockedServer.ResolveCodeLensCalls())
func (mock *ServerMock) ResolveCodeLensCalls() []struct {
	In1 context.Context
	In2 *protocol.CodeLens
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.CodeLens
	}
	lockServerMockResolveCodeLens.RLock()
	calls = mock.calls.ResolveCodeLens
	lockServerMockResolveCodeLens.RUnlock()
	return calls
}

// ResolveDocumentLink calls ResolveDocumentLinkFunc.
func (mock *ServerMock) ResolveDocumentLink(in1 context.Context, in2 *protocol.DocumentLink) (*protocol.DocumentLink, error) {
	if mock.ResolveDocumentLinkFunc == nil {
		panic("ServerMock.ResolveDocumentLinkFunc: method is nil but Server.ResolveDocumentLink was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.DocumentLink
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockResolveDocumentLink.Lock()
	mock.calls.ResolveDocumentLink = append(mock.calls.ResolveDocumentLink, callInfo)
	lockServerMockResolveDocumentLink.Unlock()
	return mock.ResolveDocumentLinkFunc(in1, in2)
}

// ResolveDocumentLinkCalls gets all the calls that were made to ResolveDocumentLink.
// Check the length with:
//     len(mockedServer.ResolveDocumentLinkCalls())
func (mock *ServerMock) ResolveDocumentLinkCalls() []struct {
	In1 context.Context
	In2 *protocol.DocumentLink
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.DocumentLink
	}
	lockServerMockResolveDocumentLink.RLock()
	calls = mock.calls.ResolveDocumentLink
	lockServerMockResolveDocumentLink.RUnlock()
	return calls
}

// SelectionRange calls SelectionRangeFunc.
func (mock *ServerMock) SelectionRange(in1 context.Context, in2 *protocol.SelectionRangeParams) ([]protocol.SelectionRange, error) {
	if mock.SelectionRangeFunc == nil {
		panic("ServerMock.SelectionRangeFunc: method is nil but Server.SelectionRange was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.SelectionRangeParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockSelectionRange.Lock()
	mock.calls.SelectionRange = append(mock.calls.SelectionRange, callInfo)
	lockServerMockSelectionRange.Unlock()
	return mock.SelectionRangeFunc(in1, in2)
}

// SelectionRangeCalls gets all the calls that were made to SelectionRange.
// Check the length with:
//     len(mockedServer.SelectionRangeCalls())
func (mock *ServerMock) SelectionRangeCalls() []struct {
	In1 context.Context
	In2 *protocol.SelectionRangeParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.SelectionRangeParams
	}
	lockServerMockSelectionRange.RLock()
	calls = mock.calls.SelectionRange
	lockServerMockSelectionRange.RUnlock()
	return calls
}

// SemanticTokens calls SemanticTokensFunc.
func (mock *ServerMock) SemanticTokens(in1 context.Context, in2 *protocol.SemanticTokensParams) (*protocol.SemanticTokens, error) {
	if mock.SemanticTokensFunc == nil {
		panic("ServerMock.SemanticTokensFunc: method is nil but Server.SemanticTokens was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.SemanticTokensParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockSemanticTokens.Lock()
	mock.calls.SemanticTokens = append(mock.calls.SemanticTokens, callInfo)
	lockServerMockSemanticTokens.Unlock()
	return mock.SemanticTokensFunc(in1, in2)
}

// SemanticTokensCalls gets all the calls that were made to SemanticTokens.
// Check the length with:
//     len(mockedServer.SemanticTokensCalls())
func (mock *ServerMock) SemanticTokensCalls() []struct {
	In1 context.Context
	In2 *protocol.SemanticTokensParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.SemanticTokensParams
	}
	lockServerMockSemanticTokens.RLock()
	calls = mock.calls.SemanticTokens
	lockServerMockSemanticTokens.RUnlock()
	return calls
}

// SemanticTokensEdits calls SemanticTokensEditsFunc.
func (mock *ServerMock) SemanticTokensEdits(in1 context.Context, in2 *protocol.SemanticTokensEditsParams) (interface{}, error) {
	if mock.SemanticTokensEditsFunc == nil {
		panic("ServerMock.SemanticTokensEditsFunc: method is nil but Server.SemanticTokensEdits was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.SemanticTokensEditsParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockSemanticTokensEdits.Lock()
	mock.calls.SemanticTokensEdits = append(mock.calls.SemanticTokensEdits, callInfo)
	lockServerMockSemanticTokensEdits.Unlock()
	return mock.SemanticTokensEditsFunc(in1, in2)
}

// SemanticTokensEditsCalls gets all the calls that were made to SemanticTokensEdits.
// Check the length with:
//     len(mockedServer.SemanticTokensEditsCalls())
func (mock *ServerMock) SemanticTokensEditsCalls() []struct {
	In1 context.Context
	In2 *protocol.SemanticTokensEditsParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.SemanticTokensEditsParams
	}
	lockServerMockSemanticTokensEdits.RLock()
	calls = mock.calls.SemanticTokensEdits
	lockServerMockSemanticTokensEdits.RUnlock()
	return calls
}

// SemanticTokensRange calls SemanticTokensRangeFunc.
func (mock *ServerMock) SemanticTokensRange(in1 context.Context, in2 *protocol.SemanticTokensRangeParams) (*protocol.SemanticTokens, error) {
	if mock.SemanticTokensRangeFunc == nil {
		panic("ServerMock.SemanticTokensRangeFunc: method is nil but Server.SemanticTokensRange was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.SemanticTokensRangeParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockSemanticTokensRange.Lock()
	mock.calls.SemanticTokensRange = append(mock.calls.SemanticTokensRange, callInfo)
	lockServerMockSemanticTokensRange.Unlock()
	return mock.SemanticTokensRangeFunc(in1, in2)
}

// SemanticTokensRangeCalls gets all the calls that were made to SemanticTokensRange.
// Check the length with:
//     len(mockedServer.SemanticTokensRangeCalls())
func (mock *ServerMock) SemanticTokensRangeCalls() []struct {
	In1 context.Context
	In2 *protocol.SemanticTokensRangeParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.SemanticTokensRangeParams
	}
	lockServerMockSemanticTokensRange.RLock()
	calls = mock.calls.SemanticTokensRange
	lockServerMockSemanticTokensRange.RUnlock()
	return calls
}

// SetTraceNotification calls SetTraceNotificationFunc.
func (mock *ServerMock) SetTraceNotification(in1 context.Context, in2 *protocol.SetTraceParams) error {
	if mock.SetTraceNotificationFunc == nil {
		panic("ServerMock.SetTraceNotificationFunc: method is nil but Server.SetTraceNotification was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.SetTraceParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockSetTraceNotification.Lock()
	mock.calls.SetTraceNotification = append(mock.calls.SetTraceNotification, callInfo)
	lockServerMockSetTraceNotification.Unlock()
	return mock.SetTraceNotificationFunc(in1, in2)
}

// SetTraceNotificationCalls gets all the calls that were made to SetTraceNotification.
// Check the length with:
//     len(mockedServer.SetTraceNotificationCalls())
func (mock *ServerMock) SetTraceNotificationCalls() []struct {
	In1 context.Context
	In2 *protocol.SetTraceParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.SetTraceParams
	}
	lockServerMockSetTraceNotification.RLock()
	calls = mock.calls.SetTraceNotification
	lockServerMockSetTraceNotification.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *ServerMock) Shutdown(in1 context.Context) error {
	if mock.ShutdownFunc == nil {
		panic("ServerMock.ShutdownFunc: method is nil but Server.Shutdown was just called")
	}
	callInfo := struct {
		In1 context.Context
	}{
		In1: in1,
	}
	lockServerMockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	lockServerMockShutdown.Unlock()
	return mock.ShutdownFunc(in1)
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//     len(mockedServer.ShutdownCalls())
func (mock *ServerMock) ShutdownCalls() []struct {
	In1 context.Context
} {
	var calls []struct {
		In1 context.Context
	}
	lockServerMockShutdown.RLock()
	calls = mock.calls.Shutdown
	lockServerMockShutdown.RUnlock()
	return calls
}

// SignatureHelp calls SignatureHelpFunc.
func (mock *ServerMock) SignatureHelp(in1 context.Context, in2 *protocol.SignatureHelpParams) (*protocol.SignatureHelp, error) {
	if mock.SignatureHelpFunc == nil {
		panic("ServerMock.SignatureHelpFunc: method is nil but Server.SignatureHelp was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.SignatureHelpParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockSignatureHelp.Lock()
	mock.calls.SignatureHelp = append(mock.calls.SignatureHelp, callInfo)
	lockServerMockSignatureHelp.Unlock()
	return mock.SignatureHelpFunc(in1, in2)
}

// SignatureHelpCalls gets all the calls that were made to SignatureHelp.
// Check the length with:
//     len(mockedServer.SignatureHelpCalls())
func (mock *ServerMock) SignatureHelpCalls() []struct {
	In1 context.Context
	In2 *protocol.SignatureHelpParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.SignatureHelpParams
	}
	lockServerMockSignatureHelp.RLock()
	calls = mock.calls.SignatureHelp
	lockServerMockSignatureHelp.RUnlock()
	return calls
}

// Symbol calls SymbolFunc.
func (mock *ServerMock) Symbol(in1 context.Context, in2 *protocol.WorkspaceSymbolParams) ([]protocol.SymbolInformation, error) {
	if mock.SymbolFunc == nil {
		panic("ServerMock.SymbolFunc: method is nil but Server.Symbol was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.WorkspaceSymbolParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockSymbol.Lock()
	mock.calls.Symbol = append(mock.calls.Symbol, callInfo)
	lockServerMockSymbol.Unlock()
	return mock.SymbolFunc(in1, in2)
}

// SymbolCalls gets all the calls that were made to Symbol.
// Check the length with:
//     len(mockedServer.SymbolCalls())
func (mock *ServerMock) SymbolCalls() []struct {
	In1 context.Context
	In2 *protocol.WorkspaceSymbolParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.WorkspaceSymbolParams
	}
	lockServerMockSymbol.RLock()
	calls = mock.calls.Symbol
	lockServerMockSymbol.RUnlock()
	return calls
}

// TypeDefinition calls TypeDefinitionFunc.
func (mock *ServerMock) TypeDefinition(in1 context.Context, in2 *protocol.TypeDefinitionParams) ([]protocol.Location, error) {
	if mock.TypeDefinitionFunc == nil {
		panic("ServerMock.TypeDefinitionFunc: method is nil but Server.TypeDefinition was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.TypeDefinitionParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockTypeDefinition.Lock()
	mock.calls.TypeDefinition = append(mock.calls.TypeDefinition, callInfo)
	lockServerMockTypeDefinition.Unlock()
	return mock.TypeDefinitionFunc(in1, in2)
}

// TypeDefinitionCalls gets all the calls that were made to TypeDefinition.
// Check the length with:
//     len(mockedServer.TypeDefinitionCalls())
func (mock *ServerMock) TypeDefinitionCalls() []struct {
	In1 context.Context
	In2 *protocol.TypeDefinitionParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.TypeDefinitionParams
	}
	lockServerMockTypeDefinition.RLock()
	calls = mock.calls.TypeDefinition
	lockServerMockTypeDefinition.RUnlock()
	return calls
}

// WillSave calls WillSaveFunc.
func (mock *ServerMock) WillSave(in1 context.Context, in2 *protocol.WillSaveTextDocumentParams) error {
	if mock.WillSaveFunc == nil {
		panic("ServerMock.WillSaveFunc: method is nil but Server.WillSave was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.WillSaveTextDocumentParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockWillSave.Lock()
	mock.calls.WillSave = append(mock.calls.WillSave, callInfo)
	lockServerMockWillSave.Unlock()
	return mock.WillSaveFunc(in1, in2)
}

// WillSaveCalls gets all the calls that were made to WillSave.
// Check the length with:
//     len(mockedServer.WillSaveCalls())
func (mock *ServerMock) WillSaveCalls() []struct {
	In1 context.Context
	In2 *protocol.WillSaveTextDocumentParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.WillSaveTextDocumentParams
	}
	lockServerMockWillSave.RLock()
	calls = mock.calls.WillSave
	lockServerMockWillSave.RUnlock()
	return calls
}

// WillSaveWaitUntil calls WillSaveWaitUntilFunc.
func (mock *ServerMock) WillSaveWaitUntil(in1 context.Context, in2 *protocol.WillSaveTextDocumentParams) ([]protocol.TextEdit, error) {
	if mock.WillSaveWaitUntilFunc == nil {
		panic("ServerMock.WillSaveWaitUntilFunc: method is nil but Server.WillSaveWaitUntil was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.WillSaveTextDocumentParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockWillSaveWaitUntil.Lock()
	mock.calls.WillSaveWaitUntil = append(mock.calls.WillSaveWaitUntil, callInfo)
	lockServerMockWillSaveWaitUntil.Unlock()
	return mock.WillSaveWaitUntilFunc(in1, in2)
}

// WillSaveWaitUntilCalls gets all the calls that were made to WillSaveWaitUntil.
// Check the length with:
//     len(mockedServer.WillSaveWaitUntilCalls())
func (mock *ServerMock) WillSaveWaitUntilCalls() []struct {
	In1 context.Context
	In2 *protocol.WillSaveTextDocumentParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.WillSaveTextDocumentParams
	}
	lockServerMockWillSaveWaitUntil.RLock()
	calls = mock.calls.WillSaveWaitUntil
	lockServerMockWillSaveWaitUntil.RUnlock()
	return calls
}

// WorkDoneProgressCancel calls WorkDoneProgressCancelFunc.
func (mock *ServerMock) WorkDoneProgressCancel(in1 context.Context, in2 *protocol.WorkDoneProgressCancelParams) error {
	if mock.WorkDoneProgressCancelFunc == nil {
		panic("ServerMock.WorkDoneProgressCancelFunc: method is nil but Server.WorkDoneProgressCancel was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.WorkDoneProgressCancelParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockWorkDoneProgressCancel.Lock()
	mock.calls.WorkDoneProgressCancel = append(mock.calls.WorkDoneProgressCancel, callInfo)
	lockServerMockWorkDoneProgressCancel.Unlock()
	return mock.WorkDoneProgressCancelFunc(in1, in2)
}

// WorkDoneProgressCancelCalls gets all the calls that were made to WorkDoneProgressCancel.
// Check the length with:
//     len(mockedServer.WorkDoneProgressCancelCalls())
func (mock *ServerMock) WorkDoneProgressCancelCalls() []struct {
	In1 context.Context
	In2 *protocol.WorkDoneProgressCancelParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.WorkDoneProgressCancelParams
	}
	lockServerMockWorkDoneProgressCancel.RLock()
	calls = mock.calls.WorkDoneProgressCancel
	lockServerMockWorkDoneProgressCancel.RUnlock()
	return calls
}

// WorkDoneProgressCreate calls WorkDoneProgressCreateFunc.
func (mock *ServerMock) WorkDoneProgressCreate(in1 context.Context, in2 *protocol.WorkDoneProgressCreateParams) error {
	if mock.WorkDoneProgressCreateFunc == nil {
		panic("ServerMock.WorkDoneProgressCreateFunc: method is nil but Server.WorkDoneProgressCreate was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *protocol.WorkDoneProgressCreateParams
	}{
		In1: in1,
		In2: in2,
	}
	lockServerMockWorkDoneProgressCreate.Lock()
	mock.calls.WorkDoneProgressCreate = append(mock.calls.WorkDoneProgressCreate, callInfo)
	lockServerMockWorkDoneProgressCreate.Unlock()
	return mock.WorkDoneProgressCreateFunc(in1, in2)
}

// WorkDoneProgressCreateCalls gets all the calls that were made to WorkDoneProgressCreate.
// Check the length with:
//     len(mockedServer.WorkDoneProgressCreateCalls())
func (mock *ServerMock) WorkDoneProgressCreateCalls() []struct {
	In1 context.Context
	In2 *protocol.WorkDoneProgressCreateParams
} {
	var calls []struct {
		In1 context.Context
		In2 *protocol.WorkDoneProgressCreateParams
	}
	lockServerMockWorkDoneProgressCreate.RLock()
	calls = mock.calls.WorkDoneProgressCreate
	lockServerMockWorkDoneProgressCreate.RUnlock()
	return calls
}
